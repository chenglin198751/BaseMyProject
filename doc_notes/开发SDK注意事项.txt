
1、如果是游戏SDK，那么所有的R资源引用必须用getIdentifier（参看工具类getResUtils），否则如果使用者使用eclipse接入就会报R文件找不到的问题。

2、混淆配置很重要，流程如下：
    1、第一次编译：aar内置自定义混淆规则，apk不要配置自定义混淆规则，二者混淆开关都设置为开启。编译APK。然后取出各个aar。此时得到的aar就是按照自定义混淆规则混淆过的代码。
    2、在demo工程建立一个空的library，此library设置混淆关。把上面拿到的aar（如果是多个aar，需要拆开合并）放到空的library下，
    此时APK的混淆设置为开，其混淆规则设置为对外CP的混淆（注意，不是aar的自定义混淆，一定要是对外CP的），此时再编译apk，得到的apk就是模拟CP的真正demo apk 。

3、混淆结果的一级目录不能出现a.a,a.b这种路径。因为如果别的SDK也混淆了也会产生a.a,a.b这种路径，那么就会导致类冲突。
    所以需要保留固定包路径：
    -keeppackagenames com.devnn.*   一颗星表示保留com.devnn下的包名不被混淆，而子包下的包名和类名都会被混淆；
    -keeppackagenames com.devnn.**  两颗星表示保留com.devnn下的所有包名不被混淆，类都会被混淆。
    特别注意，使用-keeppackagenames时，必须保证指定的包名下，至少有一个类，否则不生效。

4、引用的第三方Library越少越好；某些常用库，比如图片库，网络库，可以修改包名后引用，避免和接入方版本冲突

5、对外提供的方法，越精简越好。所有的方法，最好都有回调，回调用json格式。比如初始化方法，无论任何原因的初始化失败，都要回调给接入方；
   一个小技巧，初始化可以用CustomInitProvider实现，这样第一是方便接入方，第二是防止接入方初始化的太晚引起SDK异常。



最后附上一些常用的混淆代码：

# 不混淆某个类的类名，及类中的内容
-keep class cn.coderpig.myapp.example.Test { *; }

# 不混淆指定包名下的类名，不包括子包下的类名
-keep class cn.coderpig.myapp*

# 不混淆指定包名下的类名，及类里的内容
-keep class cn.coderpig.myapp* {*;}

# 不混淆指定包名下的类名，包括子包下的类名
-keep class cn.coderpig.myapp**

# 不混淆某个类的子类
-keep public class * extends cn.coderpig.myapp.base.BaseFragment

# 不混淆实现了某个接口的类
-keep class * implements cn.coderpig.myapp.dao.DaoImp

# 不混淆类名中包含了"entity"的类，及类中内容
-keep class **.*entity*.** {*;}

# 不混淆内部类中的所有public内容
-keep class cn.coderpig.myapp.widget.CustomView$OnClickInterface {
    public *;
}

# 不混淆指定类的所有方法
-keep cn.coderpig.myapp.example.Test {
    public <methods>;
}

# 不混淆指定类的所有字段
-keep cn.coderpig.myapp.example.Test {
    public <fields>;
}

# 不混淆指定类的所有构造方法
-keep cn.coderpig.myapp.example.Test {
    public <init>;
}

# 不混淆指定参数作为形参的方法
-keep cn.coderpig.myapp.example.Test {
    public <methods>(java.lang.String);
}

# 不混淆类的特定方法
-keep cn.coderpig.myapp.example.Test {
    public test(java.lang.String);
}

# 不混淆native方法
-keepclasseswithmembernames class * {
    native <methods>;
}

# 不混淆枚举类
-keepclassmembers enum * {
  public static **[] values();
  public static ** valueOf(java.lang.String);
}

#不混淆资源类
-keepclassmembers class **.R$* {
    public static <fields>;
}

# 不混淆自定义控件
-keep public class * entends android.view.View {
    *** get*();
    void set*(***);
    public <init>;
}

# 不混淆实现了Serializable接口的类成员，此处只是演示，也可以直接 *;
-keepclassmembers class * implements java.io.Serializable {
    static final long serialVersionUID;
    private static final java.io.ObjectStreamField[] serialPersistentFields;
    private void writeObject(java.io.ObjectOutputStream);
    private void readObject(java.io.ObjectInputStream);
    java.lang.Object writeReplace();
    java.lang.Object readResolve();
}

# 不混淆实现了parcelable接口的类成员
-keep class * implements android.os.Parcelable {
    public static final android.os.Parcelable$Creator *;
}

# 注意事项：
#
# ① jni方法不可混淆，方法名需与native方法保持一致；
# ② 反射用到的类不混淆，否则反射可能出问题；
# ③ 四大组件、Application子类、Framework层下的类、自定义的View默认不会被混淆，无需另外配置；
# ④ WebView的JS调用接口方法不可混淆；
# ⑤ 注解相关的类不混淆；
# ⑥ GSON、Fastjson等解析的Bean数据类不可混淆；
# ⑦ 枚举enum类中的values和valuesof这两个方法不可混淆(反射调用)；
# ⑧ 继承Parceable和Serializable等可序列化的类不可混淆；
# ⑨ 第三方库或SDK，请参考第三方提供的混淆规则，没提供的话，建议第三方包全部不混淆；